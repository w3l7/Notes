问题： 为什么Java自定义排序器如此编写？

想象一下，如果别人替你编写排序器，那你一定希望别人尽可能多做，你自己尽可能少做，那么少做的你**最少**要提供哪些参数呢？答案是三个参数：**容器、容器成员的量化字段（或量化方式）、排列的升降**，这意味着你希望别人向你提供的排序方法是这样的`sort(容器,量化字段,排列升降)`，于是Java排序接口的编写规则显得很奇怪，它通过比较两项数据并返回1或-1来定义了排列的升降。

这个问题困扰了我很久，直到我决定研究其源代码，当我看到自定义排序器被快速排序的代码调用后恍然大悟。

**快速排序算法**把数组分为3个部分：左部分、中值、右部分。如果是升序，左部分存储较小值，右部分存储较大值，这恰好对应了排序器的3个返回值`-1 0 1`。自定义排序器的入参即快速排序的中值。快速排序调用对象的自定义排序器并传入自己的中值以比较两者，返回1意味着此对象将被分配到右部分，若此时你的自定义排序器定义了对象大于入参时返回1，那么快速排序的右部分的值都将大于中值，这意味着升序排列。同理，如果想按降序排列，在自定义排序器中编码此对象大于中值时返回-1，那么比中值大的值将被分配到左部分。

---
